addi r3, r0, 1      //use r3 as the number 1 
addi r4, r0, 11     //use r4 as the number 11 
addi r5, r0, 3      
//start

//random number generation 2nd way:
add r5, r5, r5
addi r5, r5, 7
andi r5, r5, 63 // 63=6'b111111 = 6'd63 which is the closest number to 71 written with just ones
addi r2, r5, 0

addi r1, r0, 0
sub r4, r4, r3,
bne r4, r0, (-1) // branch if r2 !=r0
addi r4, r0, 11  // 11  because here we have +1 cycle and the next instr takes +1 cycle and every interation has 2 cycles

addi r1, r0, 1. // r1 =1 -> one light on
sub r4, r4, r3,
bne r4, r0, (-1) // branch if r2 !=r0
addi r4, r0, 11  // 11 because here we have +1 cycle and the next instr takes +1 cycle and every interation has 2 cycles


addi r1, r0, 10. // r1 =11 // -> two lights on
sub r4, r4, r3,
bne r4, r0, (-1) // branch if r2 !=r0
addi r4, r0, 11  // 11 because here we have +1 cycle and the next instr takes +1 cycle and every interation has 2 cycles

addi r1, r0, 100. // r1 =111 -> three lights on
sub r4, r4, r3,
bne r4, r0, (-1) // branch if r2 !=r0
addi r4, r0, 11  // 11 because here we have +1 cycle and the next instr takes +1 cycle and every interation has 2 cycles

addi r1, r0, 1000. // r1 =1111 -> four lights on
sub r4, r4, r3,
bne r4, r0, (-1) // branch if r2 !=r0
addi r4, r0, 11  // 11 because here we have +1 cycle and the next instr takes +1 cycle and every interation has 2 cycles

addi r1, r0, 10000. // r1 =11111 -> five lights on
sub r4, r4, r3,
bne r4, r0, (-1) // branch if r2 !=r0
addi r4, r0, 11  // 11 because here we have +1 cycle and the next instr takes +1 cycle and every interation has 2 cycles

addi r1, r0, 100000. // r1 =111111 -> six lights on
sub r4, r4, r3,
bne r4, r0, (-1) // branch if r2 !=r0
addi r4, r0, 11  // 11 because here we have +1 cycle and the next instr takes +1 cycle and every interation has 2 cycles

addi r1, r0, 1000000. // r1 =1111111 -> seven lights on
sub r4, r4, r3,
bne r4, r0, (-1) // branch if r2 !=r0
addi r4, r0, 11  // 11 because here we have +1 cycle and the next instr takes +1 cycle and every interation has 2 cycles

addi r1, r0, 10000000. // r1 =11111111 -> eight lights on

srl/sra r2, r2, r3 //divide by 2(right shift by 1) because every iteration has 2 cycles
sub r2, r2, r3           
bne r2, r0, (-1) // branch if r2 !=r0  // random delay
j start

/* implemented similar logic like in assembly.txt just instead of mod 71 I am using AND with 6'b111111 = 63 which is very 
close to 72 (3 seconds) but gives random values with NO REPETITION. The delay is much tidier and memory efficient.*/


//random number generation 3rd way max 63:
separate the 5th and 4th bit by shifting, then XOR them and put the bit at the end of the previously left shift shift random number by 1 bit

right shift (unsigned) r6 r5 by 5. // save the 5th bit  
andi r7 r5 (5'b11111)              // getting rid of the 5th bit
right shift (unsigned) r7 by 4,    // save just the 4t bit
xor r8, r6, r7                     // XOR the bits
addi r8, r8 (1'b1)                 // we just want the least signifucant bit (the XOR bit)
left shift (unsigned) r5 by 1      // we left shift the previous number one bit so we can just add the XOR bit at the end
add r5, r5, r8                     // add the XOR bit at the end

//random number generation 4th way max 2^33-1 :
 right shift the previous random number by 2 bytes and store the last byte then right shift by one byte and store the last byte.
 left shift the previous number by 1 byte and add the XORed bytes.



